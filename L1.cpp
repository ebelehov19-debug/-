// Отключение предупреждений безопасности для функций из stdio.h
#define _CRT_SECURE_NO_WARNINGS

// Подключение стандартных библиотек для ввода/вывода и работы с памятью
#include <stdio.h>
#include <stdlib.h>

// Объявление структуры для узла односвязного линейного списка
typedef struct Node1L {
    int data;                // Целочисленное значение, хранимое в узле
    struct Node1L* next;     // Указатель на следующий элемент списка
} Node1L;                    // Псевдоним Node1L для удобства использования

// Функция создания нового узла списка
Node1L* create_node_1l(int value)  // Принимает значение для нового узла
{
    // Выделение памяти под новый узел
    Node1L* new_node = (Node1L*)malloc(sizeof(Node1L));
    
    // Проверка успешности выделения памяти
    if (!new_node) exit(1);  // Если память не выделилась, завершаем программу с кодом 1
    
    // Инициализация полей нового узла
    new_node->data = value;   // Сохраняем переданное значение
    new_node->next = NULL;    // Пока не знаем следующий элемент (инициализируем как NULL)
    
    return new_node;          // Возвращаем указатель на созданный узел
}

// Функция инициализации списка (создание пустого списка)
void init_1l(Node1L** head)  // Принимает двойной указатель для изменения head в main
{
    *head = NULL;  // Устанавливаем голову списка в NULL (пустой список)
}

// Функция добавления элемента в список на указанную позицию
void add_1l(Node1L** head, int pos, int val)  // head - указатель на начало, pos - позиция, val - значение
{
    // Проверка корректности позиции (позиции начинаются с 1)
    if (pos < 1) {
        printf("Invalid position\n");  // Вывод сообщения об ошибке
        return;                         // Выход из функции
    }
    
    // Создание нового узла с заданным значением
    Node1L* new_node = create_node_1l(val);
    
    // Случай добавления в начало списка (позиция 1)
    if (pos == 1) {
        new_node->next = *head;     // Новый узел указывает на текущую голову
        *head = new_node;           // Новый узел становится новой головой
        return;                     // Выход из функции
    }
    
    // Поиск позиции для вставки (переход к элементу перед позицией вставки)
    Node1L* current = *head;        // Начинаем с головы списка
    for (int i = 1; i < pos - 1 && current; i++) {
        current = current->next;     // Переходим к следующему элементу
    }
    
    // Проверка, существует ли позиция для вставки
    if (!current) {
        printf("Position too large\n");  // Сообщение об ошибке
        free(new_node);                  // Освобождаем память созданного узла
        return;                         // Выход из функции
    }
    
    // Вставка нового узла после найденного элемента current
    new_node->next = current->next;  // Новый узел указывает на то, что было после current
    current->next = new_node;        // Current теперь указывает на новый узел
}

// Функция получения значения элемента по его позиции в списке
void get_value_at_1l(Node1L* head, int pos)  // head - начало списка, pos - искомая позиция
{
    // Проверка корректности позиции
    if (pos < 1) {
        printf("Invalid position\n");
        return;
    }
    
    // Поиск элемента на указанной позиции
    Node1L* current = head;          // Начинаем с головы списка
    for (int i = 1; i < pos && current; i++) {
        current = current->next;     // Переходим к следующему элементу
    }
    
    // Вывод результата
    if (!current) {                  // Если дошли до конца списка (элемент не найден)
        printf("Element not found\n");
    }
    else {
        printf("%d\n", current->data);  // Выводим значение найденного элемента
    }
}

// Функция поиска позиции элемента по его значению
void get_position_of_1l(Node1L* head, int val)  // head - начало списка, val - искомое значение
{
    Node1L* current = head;      // Указатель для прохода по списку
    int position = 1;            // Счетчик позиции (начинаем с 1)
    
    // Проход по всему списку
    while (current) {
        if (current->data == val) {  // Если нашли элемент с нужным значением
            printf("%d\n", position);  // Выводим его позицию
            return;                   // Выходим из функции
        }
        current = current->next;     // Переходим к следующему элементу
        position++;                  // Увеличиваем счетчик позиции
    }
    
    // Если элемент не найден
    printf("Not found\n");
}

// Функция удаления элемента по его позиции
void delete_1l(Node1L** head, int pos)  // head - указатель на начало, pos - позиция удаления
{
    // Проверка корректности позиции
    if (pos < 1) {
        printf("Invalid position\n");
        return;
    }
    
    // Проверка, не пуст ли список
    if (!*head) {
        printf("List empty\n");
        return;
    }
    
    // Случай удаления первого элемента (позиция 1)
    if (pos == 1) {
        Node1L* temp = *head;       // Сохраняем указатель на удаляемый узел
        *head = (*head)->next;      // Головой становится следующий элемент
        free(temp);                 // Освобождаем память удаляемого узла
        return;                     // Выход из функции
    }
    
    // Поиск элемента перед удаляемым (нужен для изменения связей)
    Node1L* prev = *head;           // Начинаем с головы списка
    for (int i = 1; i < pos - 1 && prev; i++) {
        prev = prev->next;          // Переходим к следующему элементу
    }
    
    // Проверка, существует ли элемент на указанной позиции
    if (!prev || !prev->next) {
        printf("Position too large\n");
        return;
    }
    
    // Находим узел для удаления (следующий после prev)
    Node1L* to_delete = prev->next;   // Узел, который нужно удалить
    
    // Обновление связей: пропускаем удаляемый узел
    prev->next = to_delete->next;     // Prev теперь указывает на элемент после удаляемого
    
    // Освобождение памяти удаляемого узла
    free(to_delete);
}

// Функция вывода всех элементов списка
void print_all_1l(Node1L* head)  // Принимает начало списка
{
    // Проверка, не пуст ли список
    if (!head) {
        printf("Empty\n");  // Вывод сообщения о пустом списке
        return;
    }
    
    Node1L* current = head;  // Указатель для прохода по списку
    
    // Проход по всем элементам списка
    while (current) {
        printf("%d ", current->data);  // Вывод значения текущего элемента
        current = current->next;        // Переход к следующему элементу
    }
    
    printf("\n");  // Перевод строки после вывода всех элементов
}

// Главная функция программы
int main()
{
    Node1L* list = NULL;  // Инициализация указателя на список (пока пустой)
    int choice, pos, val;  // Переменные для хранения выбора пользователя и данных
    
    // Бесконечный цикл обработки команд пользователя
    while (scanf("%d", &choice), choice != 0) {  // Считываем выбор, пока не введен 0
        if (choice == 1) {
            // Команда 1: Очистка списка и инициализация нового
            while (list) {  // Пока список не пустой
                Node1L* temp = list;    // Сохраняем текущую голову
                list = list->next;      // Переходим к следующему элементу
                free(temp);             // Освобождаем память текущей головы
            }
            init_1l(&list);  // Инициализируем новый пустой список
        }
        else if (choice == 2) {
            // Команда 2: Добавление элемента
            scanf("%d %d", &pos, &val);  // Считываем позицию и значение
            add_1l(&list, pos, val);     // Вызываем функцию добавления
        }
        else if (choice == 3) {
            // Команда 3: Получение значения по позиции
            scanf("%d", &pos);           // Считываем позицию
            get_value_at_1l(list, pos);  // Вызываем функцию получения значения
        }
        else if (choice == 4) {
            // Команда 4: Удаление элемента по позиции
            scanf("%d", &pos);           // Считываем позицию
            delete_1l(&list, pos);       // Вызываем функцию удаления
        }
        else if (choice == 5) {
            // Команда 5: Получение позиции по значению
            scanf("%d", &val);                 // Считываем значение
            get_position_of_1l(list, val);     // Вызываем функцию поиска позиции
        }
        else if (choice == 6) {
            // Команда 6: Вывод всех элементов списка
            print_all_1l(list);  // Вызываем функцию вывода
        }
    }
    
    // Освобождение памяти перед завершением программы
    while (list) {  // Пока список не пустой
        Node1L* temp = list;    // Сохраняем текущую голову
        list = list->next;      // Переходим к следующему элементу
        free(temp);             // Освобождаем память текущей головы
    }
    
    return 0;  // Успешное завершение программы
}
