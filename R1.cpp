// Отключение предупреждений безопасности для функций из stdio.h
#define _CRT_SECURE_NO_WARNINGS

// Подключение стандартных библиотек для ввода/вывода и работы с памятью
#include <stdio.h>
#include <stdlib.h>

// Объявление структуры для узла односвязного кольцевого списка
typedef struct Node1R {
    int data;                // Целочисленное значение, хранимое в узле
    struct Node1R* next;     // Указатель на следующий элемент списка
} Node1R;                    // Псевдоним Node1R для удобства использования

// Функция создания нового узла списка
Node1R* create_node_1r(int value)  // Принимает значение для нового узла
{
    // Выделение памяти под новый узел
    Node1R* new_node = (Node1R*)malloc(sizeof(Node1R));
    
    // Проверка успешности выделения памяти
    if (!new_node) exit(1);  // Если память не выделилась, завершаем программу с кодом 1
    
    // Инициализация полей нового узла
    new_node->data = value;   // Сохраняем переданное значение
    new_node->next = NULL;    // Пока не знаем следующий элемент (инициализируем как NULL)
    
    return new_node;          // Возвращаем указатель на созданный узел
}

// Функция инициализации списка (создание пустого списка)
// Используется указатель на хвост (последний элемент), так как в односвязном кольцевом списке
// удобнее хранить указатель на последний элемент для быстрого доступа к первому и последнему
void init_1r(Node1R** tail)  // Принимает двойной указатель для изменения tail в main
{
    *tail = NULL;  // Устанавливаем хвост списка в NULL (пустой список)
}

// Функция добавления элемента в список на указанную позицию
void add_1r(Node1R** tail, int pos, int val)  // tail - указатель на хвост, pos - позиция, val - значение
{
    // Проверка корректности позиции (позиции начинаются с 1)
    if (pos < 1) {
        printf("Invalid position\n");  // Вывод сообщения об ошибке
        return;                         // Выход из функции
    }
    
    // Случай добавления в пустой список
    if (!*tail) {
        // Проверка, что позиция должна быть 1 для пустого списка
        if (pos != 1) {
            printf("Position too large\n");  // Сообщение об ошибке
            return;                         // Выход из функции
        }
        
        // Создание нового узла для пустого списка
        Node1R* new_node = create_node_1r(val);
        new_node->next = new_node;  // В кольцевом списке один элемент ссылается сам на себя
        *tail = new_node;           // Новый узел становится хвостом списка (и единственным элементом)
        return;                     // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node1R* current = *tail;        // Начинаем с хвоста списка
    
    // Проходим по всему списку до возврата к хвосту
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != *tail);     // Пока не вернемся к хвосту
    
    // Проверка, что позиция не превышает допустимую (длина + 1 для добавления в конец)
    if (pos > length + 1) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Создание нового узла с заданным значением
    Node1R* new_node = create_node_1r(val);
    
    // Случай добавления в начало списка (позиция 1)
    // В односвязном кольцевом списке начало - это следующий элемент после хвоста
    if (pos == 1) {
        new_node->next = (*tail)->next;  // Новый узел указывает на текущую голову
        (*tail)->next = new_node;        // Хвост теперь указывает на новый узел (новая голова)
    }
    // Случай добавления в конец списка (после последнего элемента)
    else if (pos == length + 1) {
        new_node->next = (*tail)->next;  // Новый узел указывает на голову
        (*tail)->next = new_node;        // Старый хвост теперь указывает на новый узел
        *tail = new_node;                // Новый узел становится новым хвостом
    }
    // Случай добавления в середину списка
    else {
        // Начинаем с головы списка (элемент после хвоста)
        current = (*tail)->next;
        // Находим элемент на позиции перед той, куда нужно вставить
        for (int i = 1; i < pos - 1; i++) {
            current = current->next;    // Переходим к следующему элементу
        }
        
        // Вставка нового узла после найденного элемента current
        new_node->next = current->next;  // Новый узел указывает на то, что было после current
        current->next = new_node;        // Current теперь указывает на новый узел
    }
}

// Функция получения значения элемента по его позиции в списке
void get_value_at_1r(Node1R* tail, int pos)  // tail - хвост списка, pos - искомая позиция
{
    // Проверка корректности позиции и наличия элементов в списке
    if (pos < 1 || !tail) {
        printf("Invalid position or empty\n");  // Сообщение об ошибке
        return;                                 // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node1R* current = tail;         // Начинаем с хвоста списка
    
    // Проходим по всему списку до возврата к хвосту
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != tail);      // Пока не вернемся к хвосту
    
    // Проверка, что позиция не превышает длину списка
    if (pos > length) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Начинаем с головы списка (элемент после хвоста)
    current = tail->next;
    // Находим элемент на указанной позиции
    for (int i = 1; i < pos; i++) {
        current = current->next;    // Переходим к следующему элементу
    }
    
    // Вывод значения найденного элемента
    printf("%d\n", current->data);
}

// Функция поиска позиции элемента по его значению
void get_position_of_1r(Node1R* tail, int val)  // tail - хвост списка, val - искомое значение
{
    // Проверка, не пуст ли список
    if (!tail) {
        printf("Not found\n");  // Сообщение о том, что элемент не найден (список пустой)
        return;                 // Выход из функции
    }
    
    // Начинаем с головы списка (элемент после хвоста)
    Node1R* current = tail->next;
    int position = 1;            // Счетчик позиции (начинаем с 1)
    
    // Проход по всему кольцевому списку
    do {
        if (current->data == val) {  // Если нашли элемент с нужным значением
            printf("%d\n", position);  // Выводим его позицию
            return;                   // Выходим из функции
        }
        current = current->next;     // Переходим к следующему элементу
        position++;                  // Увеличиваем счетчик позиции
    } while (current != tail->next); // Пока не вернемся к голове
    
    // Если элемент не найден после полного прохода
    printf("Not found\n");
}

// Функция удаления элемента по его позиции
void delete_1r(Node1R** tail, int pos)  // tail - указатель на хвост, pos - позиция удаления
{
    // Проверка корректности позиции и наличия элементов в списке
    if (pos < 1 || !*tail) {
        printf("Invalid position or empty\n");  // Сообщение об ошибке
        return;                                 // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node1R* current = *tail;        // Начинаем с хвоста списка
    
    // Проходим по всему списку до возврата к хвосту
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != *tail);     // Пока не вернемся к хвосту
    
    // Проверка, что позиция не превышает длину списка
    if (pos > length) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Специальный случай: удаление единственного элемента в списке
    if (length == 1) {
        free(*tail);     // Освобождаем память единственного элемента
        *tail = NULL;    // Устанавливаем хвост в NULL (пустой список)
        return;          // Выход из функции
    }
    
    // Случай удаления первого элемента (головы списка)
    if (pos == 1) {
        Node1R* head = (*tail)->next;     // Сохраняем указатель на голову
        (*tail)->next = head->next;       // Хвост теперь указывает на второй элемент
        free(head);                       // Освобождаем память удаляемой головы
    }
    // Случай удаления элемента из середины или конца списка
    else {
        // Начинаем с головы списка
        current = (*tail)->next;
        // Находим элемент перед удаляемым
        for (int i = 1; i < pos - 1; i++) {
            current = current->next;      // Переходим к следующему элементу
        }
        
        Node1R* to_delete = current->next;  // Элемент, который нужно удалить
        
        // Обновление связей: пропускаем удаляемый узел
        current->next = to_delete->next;    // Current теперь указывает на элемент после удаляемого
        
        // Если удаляется последний элемент (хвост)
        if (to_delete == *tail) {
            *tail = current;                 // Предыдущий элемент становится новым хвостом
        }
        
        // Освобождение памяти удаляемого узла
        free(to_delete);
    }
}

// Функция вывода всех элементов списка
void print_all_1r(Node1R* tail)  // Принимает хвост списка
{
    // Проверка, не пуст ли список
    if (!tail) {
        printf("Empty\n");  // Вывод сообщения о пустом списке
        return;
    }
    
    // Начинаем с головы списка (элемент после хвоста)
    Node1R* current = tail->next;
    
    // Проход по всем элементам кольцевого списка
    do {
        printf("%d ", current->data);  // Вывод значения текущего элемента
        current = current->next;        // Переход к следующему элементу
    } while (current != tail->next);    // Пока не вернемся к голове
    
    printf("\n");  // Перевод строки после вывода всех элементов
}

// Главная функция программы
int main()
{
    Node1R* list = NULL;  // Инициализация указателя на список (храним хвост, пока NULL)
    int choice, pos, val;  // Переменные для хранения выбора пользователя и данных
    
    // Бесконечный цикл обработки команд пользователя
    while (scanf("%d", &choice), choice != 0) {  // Считываем выбор, пока не введен 0
        if (choice == 1) {
            // Команда 1: Очистка списка и инициализация нового
            if (list) {  // Если список не пустой
                // Проходим по всем элементам, начиная с головы (элемент после хвоста)
                Node1R* current = list->next;
                while (current != list) {  // Пока не вернемся к хвосту
                    Node1R* temp = current;  // Сохраняем текущий узел
                    current = current->next;  // Переходим к следующему
                    free(temp);               // Освобождаем память текущего
                }
                free(list);  // Освобождаем память хвоста списка
            }
            init_1r(&list);  // Инициализируем новый пустой список
        }
        else if (choice == 2) {
            // Команда 2: Добавление элемента
            scanf("%d %d", &pos, &val);  // Считываем позицию и значение
            add_1r(&list, pos, val);     // Вызываем функцию добавления
        }
        else if (choice == 3) {
            // Команда 3: Получение значения по позиции
            scanf("%d", &pos);           // Считываем позицию
            get_value_at_1r(list, pos);  // Вызываем функцию получения значения
        }
        else if (choice == 4) {
            // Команда 4: Удаление элемента по позиции
            scanf("%d", &pos);           // Считываем позицию
            delete_1r(&list, pos);       // Вызываем функцию удаления
        }
        else if (choice == 5) {
            // Команда 5: Получение позиции по значению
            scanf("%d", &val);                 // Считываем значение
            get_position_of_1r(list, val);     // Вызываем функцию поиска позиции
        }
        else if (choice == 6) {
            // Команда 6: Вывод всех элементов списка
            print_all_1r(list);  // Вызываем функцию вывода
        }
    }
    
    // Освобождение памяти перед завершением программы
    if (list) {  // Если список не пустой
        // Проходим по всем элементам, начиная с головы (элемент после хвоста)
        Node1R* current = list->next;
        while (current != list) {  // Пока не вернемся к хвосту
            Node1R* temp = current;  // Сохраняем текущий узел
            current = current->next;  // Переходим к следующему
            free(temp);               // Освобождаем память текущего
        }
        free(list);  // Освобождаем память хвоста списка
    }
    
    return 0;  // Успешное завершение программы
}
