// Отключение предупреждений безопасности для функций из stdio.h
#define _CRT_SECURE_NO_WARNINGS

// Подключение стандартных библиотек для ввода/вывода и работы с памятью
#include <stdio.h>
#include <stdlib.h>

// Объявление структуры для узла двусвязного кольцевого списка
typedef struct Node2R {
    int data;                // Целочисленное значение, хранимое в узле
    struct Node2R* next;     // Указатель на следующий элемент списка
    struct Node2R* prev;     // Указатель на предыдущий элемент списка
} Node2R;                    // Псевдоним Node2R для удобства использования

// Функция создания нового узла списка
Node2R* create_node_2r(int value)  // Принимает значение для нового узла
{
    // Выделение памяти под новый узел
    Node2R* new_node = (Node2R*)malloc(sizeof(Node2R));
    
    // Проверка успешности выделения памяти
    if (!new_node) exit(1);  // Если память не выделилась, завершаем программу с кодом 1
    
    // Инициализация полей нового узла
    new_node->data = value;   // Сохраняем переданное значение
    new_node->next = NULL;    // Пока не знаем следующий элемент
    new_node->prev = NULL;    // Пока не знаем предыдущий элемент
    
    return new_node;          // Возвращаем указатель на созданный узел
}

// Функция инициализации списка (создание пустого списка)
void init_2r(Node2R** head)  // Принимает двойной указатель для изменения head в main
{
    *head = NULL;  // Устанавливаем голову списка в NULL (пустой список)
}

// Функция добавления элемента в список на указанную позицию
void add_2r(Node2R** head, int pos, int val)  // head - указатель на начало, pos - позиция, val - значение
{
    // Проверка корректности позиции (позиции начинаются с 1)
    if (pos < 1) {
        printf("Invalid position\n");  // Вывод сообщения об ошибке
        return;                         // Выход из функции
    }
    
    // Случай добавления в пустой список
    if (!*head) {
        // Проверка, что позиция должна быть 1 для пустого списка
        if (pos != 1) {
            printf("Position too large\n");  // Сообщение об ошибке
            return;                         // Выход из функции
        }
        
        // Создание нового узла для пустого списка
        Node2R* new_node = create_node_2r(val);
        new_node->next = new_node;  // В кольцевом списке один элемент ссылается сам на себя
        new_node->prev = new_node;  // И спереди, и сзади
        *head = new_node;           // Новый узел становится головой списка
        return;                     // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node2R* current = *head;        // Начинаем с головы списка
    
    // Проходим по всему списку до возврата к голове
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != *head);     // Пока не вернемся к голове
    
    // Проверка, что позиция не превышает допустимую (длина + 1 для добавления в конец)
    if (pos > length + 1) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Создание нового узла с заданным значением
    Node2R* new_node = create_node_2r(val);
    
    // Случай добавления в начало списка (позиция 1)
    if (pos == 1) {
        new_node->next = *head;                 // Новый узел указывает на текущую голову
        new_node->prev = (*head)->prev;         // Новый узел указывает назад на последний элемент
        (*head)->prev->next = new_node;         // Последний элемент теперь указывает на новый
        (*head)->prev = new_node;               // Текущая голова теперь указывает назад на новый
        *head = new_node;                       // Новый узел становится новой головой
    }
    // Случай добавления в конец списка (после последнего элемента)
    else if (pos == length + 1) {
        new_node->next = *head;                 // Новый узел (последний) указывает на голову
        new_node->prev = (*head)->prev;         // Новый узел указывает назад на бывший последний
        (*head)->prev->next = new_node;         // Бывший последний теперь указывает на новый
        (*head)->prev = new_node;               // Голова теперь указывает назад на новый (теперь последний)
    }
    // Случай добавления в середину списка
    else {
        current = *head;                        // Начинаем с головы списка
        // Находим элемент на позиции, куда нужно вставить
        for (int i = 1; i < pos; i++) {
            current = current->next;            // Переходим к следующему элементу
        }
        
        // Вставка нового узла перед найденным элементом current
        new_node->next = current;               // Новый узел указывает на current
        new_node->prev = current->prev;         // Новый узел указывает назад на предыдущий от current
        current->prev->next = new_node;         // Предыдущий от current теперь указывает на новый
        current->prev = new_node;               // Current теперь указывает назад на новый
    }
}

// Функция получения значения элемента по его позиции в списке
void get_value_at_2r(Node2R* head, int pos)  // head - начало списка, pos - искомая позиция
{
    // Проверка корректности позиции и наличия элементов в списке
    if (pos < 1 || !head) {
        printf("Invalid position or empty\n");  // Сообщение об ошибке
        return;                                 // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node2R* current = head;         // Начинаем с головы списка
    
    // Проходим по всему списку до возврата к голове
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != head);      // Пока не вернемся к голове
    
    // Проверка, что позиция не превышает длину списка
    if (pos > length) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Поиск элемента на указанной позиции
    current = head;                     // Начинаем с головы списка
    for (int i = 1; i < pos; i++) {
        current = current->next;        // Переходим к следующему элементу
    }
    
    // Вывод значения найденного элемента
    printf("%d\n", current->data);
}

// Функция поиска позиции элемента по его значению
void get_position_of_2r(Node2R* head, int val)  // head - начало списка, val - искомое значение
{
    // Проверка, не пуст ли список
    if (!head) {
        printf("Not found\n");  // Сообщение о том, что элемент не найден (список пустой)
        return;                 // Выход из функции
    }
    
    Node2R* current = head;      // Указатель для прохода по списку
    int position = 1;            // Счетчик позиции (начинаем с 1)
    
    // Проход по всему кольцевому списку
    do {
        if (current->data == val) {  // Если нашли элемент с нужным значением
            printf("%d\n", position);  // Выводим его позицию
            return;                   // Выходим из функции
        }
        current = current->next;     // Переходим к следующему элементу
        position++;                  // Увеличиваем счетчик позиции
    } while (current != head);       // Пока не вернемся к голове
    
    // Если элемент не найден после полного прохода
    printf("Not found\n");
}

// Функция удаления элемента по его позиции
void delete_2r(Node2R** head, int pos)  // head - указатель на начало, pos - позиция удаления
{
    // Проверка корректности позиции и наличия элементов в списке
    if (pos < 1 || !*head) {
        printf("Invalid position or empty\n");  // Сообщение об ошибке
        return;                                 // Выход из функции
    }
    
    // Подсчет длины кольцевого списка
    int length = 0;                 // Счетчик длины
    Node2R* current = *head;        // Начинаем с головы списка
    
    // Проходим по всему списку до возврата к голове
    do {
        length++;                   // Увеличиваем счетчик длины
        current = current->next;    // Переходим к следующему элементу
    } while (current != *head);     // Пока не вернемся к голове
    
    // Проверка, что позиция не превышает длину списка
    if (pos > length) {
        printf("Position too large\n");  // Сообщение об ошибке
        return;                         // Выход из функции
    }
    
    // Поиск удаляемого элемента
    current = *head;                     // Начинаем с головы списка
    for (int i = 1; i < pos; i++) {
        current = current->next;         // Переходим к следующему элементу
    }
    
    // Обновление связей между соседними узлами (минуя удаляемый)
    current->prev->next = current->next;  // Предыдущий теперь указывает на следующий
    current->next->prev = current->prev;  // Следующий теперь указывает на предыдущий
    
    // Если удаляется первый элемент списка
    if (current == *head) {
        *head = (length == 1) ? NULL : current->next;  // Если был один элемент - NULL, иначе следующий
    }
    
    // Освобождение памяти удаляемого узла
    free(current);
    
    // Дополнительная проверка для случая, когда был один элемент
    if (length == 1) {
        *head = NULL;  // Гарантируем, что список пустой
    }
}

// Функция вывода всех элементов списка
void print_all_2r(Node2R* head)  // Принимает начало списка
{
    // Проверка, не пуст ли список
    if (!head) {
        printf("Empty\n");  // Вывод сообщения о пустом списке
        return;
    }
    
    Node2R* current = head;  // Указатель для прохода по списку
    
    // Проход по всем элементам кольцевого списка
    do {
        printf("%d ", current->data);  // Вывод значения текущего элемента
        current = current->next;        // Переход к следующему элементу
    } while (current != head);          // Пока не вернемся к голове
    
    printf("\n");  // Перевод строки после вывода всех элементов
}

// Главная функция программы
int main()
{
    Node2R* list = NULL;  // Инициализация указателя на список (пока пустой)
    int choice, pos, val;  // Переменные для хранения выбора пользователя и данных
    
    // Бесконечный цикл обработки команд пользователя
    while (scanf("%d", &choice), choice != 0) {  // Считываем выбор, пока не введен 0
        if (choice == 1) {
            // Команда 1: Очистка списка и инициализация нового
            if (list) {  // Если список не пустой
                // Проходим по всем элементам, начиная со второго
                Node2R* current = list->next;
                while (current != list) {  // Пока не вернемся к голове
                    Node2R* temp = current;  // Сохраняем текущий узел
                    current = current->next;  // Переходим к следующему
                    free(temp);               // Освобождаем память текущего
                }
                free(list);  // Освобождаем память головы списка
            }
            init_2r(&list);  // Инициализируем новый пустой список
        }
        else if (choice == 2) {
            // Команда 2: Добавление элемента
            scanf("%d %d", &pos, &val);  // Считываем позицию и значение
            add_2r(&list, pos, val);     // Вызываем функцию добавления
        }
        else if (choice == 3) {
            // Команда 3: Получение значения по позиции
            scanf("%d", &pos);           // Считываем позицию
            get_value_at_2r(list, pos);  // Вызываем функцию получения значения
        }
        else if (choice == 4) {
            // Команда 4: Удаление элемента по позиции
            scanf("%d", &pos);           // Считываем позицию
            delete_2r(&list, pos);       // Вызываем функцию удаления
        }
        else if (choice == 5) {
            // Команда 5: Получение позиции по значению
            scanf("%d", &val);                 // Считываем значение
            get_position_of_2r(list, val);     // Вызываем функцию поиска позиции
        }
        else if (choice == 6) {
            // Команда 6: Вывод всех элементов списка
            print_all_2r(list);  // Вызываем функцию вывода
        }
    }
    
    // Освобождение памяти перед завершением программы
    if (list) {  // Если список не пустой
        // Проходим по всем элементам, начиная со второго
        Node2R* current = list->next;
        while (current != list) {  // Пока не вернемся к голове
            Node2R* temp = current;  // Сохраняем текущий узел
            current = current->next;  // Переходим к следующему
            free(temp);               // Освобождаем память текущего
        }
        free(list);  // Освобождаем память головы списка
    }
    
    return 0;  // Успешное завершение программы
}
