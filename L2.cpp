// Отключение предупреждений безопасности для функций из stdio.h
#define _CRT_SECURE_NO_WARNINGS

// Подключение стандартных библиотек для ввода/вывода и работы с памятью
#include <stdio.h>
#include <stdlib.h>

// Объявление структуры для узла двусвязного линейного списка
typedef struct Node2L {
    int data;                // Целочисленное значение, хранимое в узле
    struct Node2L* next;     // Указатель на следующий элемент списка
    struct Node2L* prev;     // Указатель на предыдущий элемент списка
} Node2L;                    // Псевдоним Node2L для удобства использования

// Функция создания нового узла списка
Node2L* create_node_2l(int value)  // Принимает значение для нового узла
{
    // Выделение памяти под новый узел
    Node2L* new_node = (Node2L*)malloc(sizeof(Node2L));
    
    // Проверка успешности выделения памяти
    if (!new_node) exit(1);  // Если память не выделилась, завершаем программу с кодом 1
    
    // Инициализация полей нового узла
    new_node->data = value;   // Сохраняем переданное значение
    new_node->next = NULL;    // Пока не знаем следующий элемент
    new_node->prev = NULL;    // Пока не знаем предыдущий элемент
    
    return new_node;          // Возвращаем указатель на созданный узел
}

// Функция инициализации списка (создание пустого списка)
void init_2l(Node2L** head)  // Принимает двойной указатель для изменения head в main
{
    *head = NULL;  // Устанавливаем голову списка в NULL (пустой список)
}

// Функция добавления элемента в список на указанную позицию
void add_2l(Node2L** head, int pos, int val)  // head - указатель на начало, pos - позиция, val - значение
{
    // Проверка корректности позиции (позиции начинаются с 1)
    if (pos < 1) {
        printf("Invalid position\n");  // Вывод сообщения об ошибке
        return;                         // Выход из функции
    }
    
    // Создание нового узла с заданным значением
    Node2L* new_node = create_node_2l(val);
    
    // Случай добавления в начало списка
    if (pos == 1) {
        new_node->next = *head;     // Новый узел указывает на текущую голову
        if (*head) {                // Если список не пустой
            (*head)->prev = new_node;  // Текущая голова теперь имеет предыдущий элемент
        }
        *head = new_node;           // Новый узел становится новой головой
        return;                     // Выход из функции
    }
    
    // Поиск позиции для вставки (переход к элементу перед позицией вставки)
    Node2L* current = *head;        // Начинаем с головы списка
    for (int i = 1; i < pos - 1 && current; i++) {
        current = current->next;     // Переходим к следующему элементу
    }
    
    // Проверка, существует ли позиция для вставки
    if (!current) {
        printf("Position too large\n");  // Сообщение об ошибке
        free(new_node);                  // Освобождаем память созданного узла
        return;                         // Выход из функции
    }
    
    // Вставка нового узла после найденного элемента current
    new_node->next = current->next;  // Новый узел указывает на то, что было после current
    new_node->prev = current;        // Новый узел указывает назад на current
    
    // Если мы не вставляем в конец списка
    if (current->next) {
        current->next->prev = new_node;  // Следующий узел теперь указывает назад на новый
    }
    
    current->next = new_node;        // Current теперь указывает на новый узел
}

// Функция получения значения элемента по его позиции в списке
void get_value_at_2l(Node2L* head, int pos)  // head - начало списка, pos - искомая позиция
{
    // Проверка корректности позиции
    if (pos < 1) {
        printf("Invalid position\n");
        return;
    }
    
    // Поиск элемента на указанной позиции
    Node2L* current = head;          // Начинаем с головы списка
    for (int i = 1; i < pos && current; i++) {
        current = current->next;     // Переходим к следующему элементу
    }
    
    // Вывод результата
    if (!current) {                  // Если дошли до конца списка
        printf("Element not found\n");
    }
    else {
        printf("%d\n", current->data);  // Выводим значение найденного элемента
    }
}

// Функция поиска позиции элемента по его значению
void get_position_of_2l(Node2L* head, int val)  // head - начало списка, val - искомое значение
{
    Node2L* current = head;      // Указатель для прохода по списку
    int position = 1;            // Счетчик позиции (начинаем с 1)
    
    // Проход по всему списку
    while (current) {
        if (current->data == val) {  // Если нашли элемент с нужным значением
            printf("%d\n", position);  // Выводим его позицию
            return;                   // Выходим из функции
        }
        current = current->next;     // Переходим к следующему элементу
        position++;                  // Увеличиваем счетчик позиции
    }
    
    // Если элемент не найден
    printf("Not found\n");
}

// Функция удаления элемента по его позиции
void delete_2l(Node2L** head, int pos)  // head - указатель на начало, pos - позиция удаления
{
    // Проверка корректности позиции
    if (pos < 1) {
        printf("Invalid position\n");
        return;
    }
    
    // Проверка, не пуст ли список
    if (!*head) {
        printf("List empty\n");
        return;
    }
    
    // Поиск удаляемого элемента
    Node2L* current = *head;          // Начинаем с головы
    for (int i = 1; i < pos && current; i++) {
        current = current->next;      // Переходим к следующему элементу
    }
    
    // Проверка, существует ли элемент на указанной позиции
    if (!current) {
        printf("Position too large\n");
        return;
    }
    
    // Обновление связей между соседними узлами
    if (current->prev) {                    // Если есть предыдущий узел
        current->prev->next = current->next;  // Предыдущий теперь указывает на следующий
    }
    
    if (current->next) {                    // Если есть следующий узел
        current->next->prev = current->prev;  // Следующий теперь указывает на предыдущий
    }
    
    // Если удаляется первый элемент списка
    if (current == *head) {
        *head = current->next;  // Головой становится следующий элемент
    }
    
    // Освобождение памяти удаляемого узла
    free(current);
}

// Функция вывода всех элементов списка
void print_all_2l(Node2L* head)  // Принимает начало списка
{
    // Проверка, не пуст ли список
    if (!head) {
        printf("Empty\n");  // Вывод сообщения о пустом списке
        return;
    }
    
    Node2L* current = head;  // Указатель для прохода по списку
    
    // Проход по всем элементам списка
    while (current) {
        printf("%d ", current->data);  // Вывод значения текущего элемента
        current = current->next;        // Переход к следующему элементу
    }
    
    printf("\n");  // Перевод строки после вывода всех элементов
}

// Главная функция программы
int main()
{
    Node2L* list = NULL;  // Инициализация указателя на список (пока пустой)
    int choice, pos, val;  // Переменные для хранения выбора пользователя и данных
    
    // Бесконечный цикл обработки команд пользователя
    while (scanf("%d", &choice), choice != 0) {  // Считываем выбор, пока не введен 0
        if (choice == 1) {
            // Команда 1: Очистка списка и инициализация нового
            while (list) {  // Пока список не пустой
                Node2L* temp = list;    // Сохраняем текущую голову
                list = list->next;      // Переходим к следующему элементу
                free(temp);             // Освобождаем память текущей головы
            }
            init_2l(&list);  // Инициализируем новый пустой список
        }
        else if (choice == 2) {
            // Команда 2: Добавление элемента
            scanf("%d %d", &pos, &val);  // Считываем позицию и значение
            add_2l(&list, pos, val);     // Вызываем функцию добавления
        }
        else if (choice == 3) {
            // Команда 3: Получение значения по позиции
            scanf("%d", &pos);           // Считываем позицию
            get_value_at_2l(list, pos);  // Вызываем функцию получения значения
        }
        else if (choice == 4) {
            // Команда 4: Удаление элемента по позиции
            scanf("%d", &pos);           // Считываем позицию
            delete_2l(&list, pos);       // Вызываем функцию удаления
        }
        else if (choice == 5) {
            // Команда 5: Получение позиции по значению
            scanf("%d", &val);                 // Считываем значение
            get_position_of_2l(list, val);     // Вызываем функцию поиска позиции
        }
        else if (choice == 6) {
            // Команда 6: Вывод всех элементов списка
            print_all_2l(list);  // Вызываем функцию вывода
        }
    }
    
    // Освобождение памяти перед завершением программы
    while (list) {  // Пока список не пустой
        Node2L* temp = list;    // Сохраняем текущую голову
        list = list->next;      // Переходим к следующему элементу
        free(temp);             // Освобождаем память текущей головы
    }
    
    return 0;  // Успешное завершение программы
}
